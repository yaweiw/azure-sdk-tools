// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.IaaS.Extensions.MicrosoftAntimalware
{
    using System;
    using System.Linq;
    using System.Text;
    using System.Xml;
    using System.IO;
    using System.Management.Automation;
    using Microsoft.WindowsAzure.Commands.ServiceManagement.Model;
    
    [Cmdlet(
        VerbsCommon.Set,
        VirtualMachineMicrosoftAntimalwareExtensionNoun,
        DefaultParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName),
    OutputType(
        typeof(IPersistentVM))]
    public class SetAzureVMMicrosoftAntimalwareExtensionCommand : VirtualMachineMicrosoftAntimalwareExtensionCmdletBase
    {
        public const string EnableMicrosoftAntimalwareExtensionParamSetName = "EnableMicrosoftAntimalwareExtension";
        public const string DisableMicrosoftAntimalwareExtensionParamSetName = "DisableMicrosoftAntimalwareExtension";
        public const string UninstallMicrosoftAntimalwareExtensionParamSetName = "UninstallMicrosoftAntimalwareExtension";

        [Parameter(
            ParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 1,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "The Microsoft Antimalware Configuration")]
        [ValidateNotNullOrEmpty]
        public override XmlDocument AntimalwareConfiguration
        {
            get;
            set;
        }

        [Parameter(
            ParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 2,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "The Microsoft Antimalware Configuration File Path")]
        [ValidateNotNullOrEmpty]
        public override string AntimalwareConfigFile
        {
            get;
            set;
        }

        [Parameter(
            ParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 3,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "The Extension Version")]
        [Parameter(
            ParameterSetName = DisableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 1,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "The Extension Version")]
        [ValidateNotNullOrEmpty]
        public override string Version { get; set; }

        [Parameter(
            ParameterSetName = DisableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 2,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "Disable VM Microsoft Antimalware Extension")]
        public override SwitchParameter Disable { get; set; }

        [Parameter(
            ParameterSetName = UninstallMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = true,
            Position = 1,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "Uninstall VM Microsoft Antimalware Extension")]
        public override SwitchParameter Uninstall { get; set; }

        [Parameter(
            ParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 4,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "Microsoft Antimalware Event Monitoring (ON/OFF)")]
        [ValidateSet("ON", "OFF", IgnoreCase = true)]
        public string Monitoring
        {
            get;
            set;
        }

        [Parameter(
            ParameterSetName = EnableMicrosoftAntimalwareExtensionParamSetName,
            Mandatory = false,
            Position = 5,
            ValueFromPipelineByPropertyName = true,
            HelpMessage = "Microsoft Antimalware Monitoring Storage Account Name")]
        [ValidateNotNullOrEmpty]
        public override string StorageAccountName
        {
            get;
            set;
        }

        private bool isAntimalwareEnabled = false;   // do not enable antimalware unless specified in configuration or parameters
        private enum MonitoringActionType { Enable, Disable, NoActionRequested } ;
        private MonitoringActionType monitoringAction = MonitoringActionType.NoActionRequested; // default to no action requested until identified in config or parameter
        private string monitoringStorageAccountName; // for retrieving storage account name when specified in config file

        internal void ExecuteCommand()
        {
            ValidateParameters();

            // set diagnostics extension
            InitializeDiagnosticsSettings();
            switch (monitoringAction)
            {
                // enable and disable are expected to update the diagnostics extension if needed 
                // resource extension will be added by EnableMonitoring or RemoveExistingAntimalwareMonitoringConfig as needed
                case MonitoringActionType.Enable: EnableMonitoring(); break;
                case MonitoringActionType.Disable: RemoveExistingAntimalwareMonitoringConfig(); break;
                default: break;
            }

            // set antimalware extension
            InitializeAntimalwareSettings();
            RemovePredicateExtensions();
            AddResourceExtension();  

            WriteObject(VM);
        }

        private string GetBase64EncodedAntimalwareConfig()
        {
            string base64EncodedXmlConfig = null;

            if (AntimalwareConfiguration != null)
            {
                // replace the default configuration with the configuration supplied as parameter
                base64EncodedXmlConfig = Convert.ToBase64String(Encoding.UTF8.GetBytes(AntimalwareConfiguration.OuterXml.ToString()));
            }
            else if (AntimalwareConfigFile != null)
            {
                if ((!string.IsNullOrWhiteSpace(AntimalwareConfigFile)) && File.Exists(AntimalwareConfigFile))
                {
                    string xmlString = File.ReadAllText(AntimalwareConfigFile);
                    base64EncodedXmlConfig = Convert.ToBase64String(Encoding.UTF8.GetBytes(xmlString));
                }
            }

            return base64EncodedXmlConfig;
        }

        private string GetJsonEncodedAntimalwareConfig()
        {
            string base64EncodedXmlConfig = GetBase64EncodedAntimalwareConfig();

            if (!string.IsNullOrWhiteSpace(base64EncodedXmlConfig))
            {
                // wrap in json formatting and return
                return string.Format(MicrosoftAntimalwareExtensionPublicConfigurationTemplate, EscapeJsonCharacters(base64EncodedXmlConfig));
            }
            else
            {
                return null;
            }
        }

        private string GetJsonEncodedDiagnosticsConfig(string xmlConfigStr)
        {
            return "{ \"xmlCfg\":\"" + Convert.ToBase64String(Encoding.UTF8.GetBytes(xmlConfigStr.ToCharArray())) + "\"}";
                    //"\", \"storageAccountName\":\"" + StorageAccountName + "\"}";
        }
        
        protected override void ValidateParameters()
        {
            base.ValidateParameters();
            ValidateConfiguration();
            this.ReferenceName = string.IsNullOrEmpty(this.ReferenceName) ? MicrosoftAntimalwareExtensionName : this.ReferenceName;
            this.Version = this.Version ?? MicrosoftAntimalwareExtensionDefaultVersion;
            this.PublicConfiguration = string.Format(MicrosoftAntimalwareExtensionPublicConfigurationTemplate,EscapeJsonCharacters(GetJsonEncodedAntimalwareConfig()));
        }

        protected override void ProcessRecord()
        {
            base.ProcessRecord();
            ExecuteCommand();
        }

        private string EscapeJsonCharacters(string value)
        {
            string serializedValue = Newtonsoft.Json.JsonConvert.SerializeObject(value);

            // Since SerializeObject method automatically surrounds result with double quotes, we need to remove them.
            return serializedValue.Trim('"');
        }

        protected void InitializeAntimalwareSettings()
        {
            Publisher = MicrosoftAntimalwareExtensionNamespace;
            ExtensionName = MicrosoftAntimalwareExtensionName;
            ReferenceName = MicrosoftAntimalwareExtensionReferenceName;

            PublicConfiguration = GetJsonEncodedAntimalwareConfig();
            PrivateConfiguration = null;  
        }

        protected void InitializeDiagnosticsSettings()
        {
            Publisher = DiagnosticsExtensionNamespace;
            ExtensionName = DiagnosticsExtensionName;
            ReferenceName = DiagnosticsExtensionReferenceName;

            // create the required public configuration xml fragment and encode
            string diagCfgXmlStr = string.Format("<{0}>{1}</{0}><{2}>{3}</{2}>", DiagnosticsConfigElementName, DiagnosticsDefaultConfigNewXmlStr, StorageAccountElementName, StorageAccountName);
            PublicConfiguration = GetJsonEncodedDiagnosticsConfig(diagCfgXmlStr);

            // set up default private configuration
            if (!string.IsNullOrWhiteSpace(StorageKey))
            {
                PrivateConfiguration = GetPrivateConfiguration();
            }
            else
            {
                // not ready to set private configuration
                PrivateConfiguration = null;
            }
        }

        private string GetPrivateConfiguration()
        {
            return string.Format(@"{{ ""storageAccountName"":""{0}"",""storageAccountKey"":""{1}""}}",StorageAccountName,StorageKey);
        }

        protected void ValidateConfiguration()
        {
            // if no AntimalwareConfiguration XmlDocument was provided, use the AntimalwareConfigFile parameter
            if ((AntimalwareConfiguration == null) && (AntimalwareConfigFile != null))
            {
                if ((!string.IsNullOrWhiteSpace(AntimalwareConfigFile)) && File.Exists(AntimalwareConfigFile))
                {
                    AntimalwareConfiguration = new XmlDocument();
                    AntimalwareConfiguration.XmlResolver = null;
                    AntimalwareConfiguration.Load(AntimalwareConfigFile);
                }
                else
                {
                    ThrowTerminatingError(new ErrorRecord(
                        new Exception("ServiceExtensionCannotFindAntimalwareConfigFile"),
                        string.Empty,
                        ErrorCategory.InvalidData,
                        null));
                }
            }

            // read values from xml file if provided
            if (AntimalwareConfiguration != null)
            {
                // check for antimalware enabled 
                XmlNode antimalwareEnabledNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/AntimalwareEnabled");
                if ((antimalwareEnabledNode != null) && (antimalwareEnabledNode.InnerText != null))
                {
                    isAntimalwareEnabled = antimalwareEnabledNode.InnerText.ToUpperInvariant().Equals("TRUE");
                }
                else
                {
                    // user provided a config that did not properly opt-in to enable antimalware
                    ThrowTerminatingError(new ErrorRecord(
                                new Exception("ServiceExtensionCannotFindAntimalwareEnableSetting"),
                                string.Empty,
                                ErrorCategory.InvalidData,
                                null));
                }

                // check for monitoring enabled 
                XmlNode monitoringNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/Monitoring");
                if (monitoringNode != null)
                {
                    if (monitoringNode.InnerText != null)
                    {
                        switch (monitoringNode.InnerText.ToUpperInvariant())
                        {
                            case "ON": monitoringAction = MonitoringActionType.Enable; break;
                            case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                            default: break;
                        }
                    }

                    // now remove the monitoring node from the xml document since it 
                    // is not recognized by the schema used by the antimalware extension
                    monitoringNode.ParentNode.RemoveChild(monitoringNode);
                }

                // check for storage account name if present in the config file
                XmlNode storageAccountNameNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/StorageAccountName");
                if (storageAccountNameNode != null)
                {
                    if (storageAccountNameNode.InnerText != null)
                    {
                        monitoringStorageAccountName = storageAccountNameNode.InnerText;
                    }
                    // strip this node from the xml prior to passing to antimalware extension
                    storageAccountNameNode.ParentNode.RemoveChild(storageAccountNameNode);
                }
            }

            // process Monitoring parameter if specified (will override any setting in xml config)
            if (Monitoring != null)
            {
                switch (Monitoring.ToUpperInvariant())
                {
                    case "ON": monitoringAction = MonitoringActionType.Enable; break;
                    case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                    default: break;
                }
            }
        }

        private void AddNewAntimalwareMonitoringConfig()
        {
            InitializeDiagnosticsSettings();
            RemovePredicateExtensions();
            AddResourceExtension();
        }

        private void MergeAntimalwareMonitoringIntoExistingConfig(string existingConfigXmlStr, string existingReferenceName)
        {
            // prepare a new xml document to hold the merged config
            XmlDocument mergedConfig = new XmlDocument();
            // add root element back to xml string (not preserved by diagnostics extension)
            string tmpXmlString = string.Format("<PublicConfig xmlns=\"{0}\">{1}</PublicConfig>", DiagnosticsConfigXmlNamespace, existingConfigXmlStr);
            mergedConfig.LoadXml(tmpXmlString);

            // check if old config already contains a WindowsEventLog section
            string targetNode;
            string mergeXmlStr;
            if (existingConfigXmlStr.Contains(DiagnosticsConfigWindowsEventLogNodeName))
            {
                // inject into the existing windows event log section 
                targetNode = DiagnosticsConfigWindowsEventLogNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode;
            }
            else
            {
                // inject a windows event log section with antimalware monitoring into the diagnostics config 
                targetNode = DiagnosticsConfigNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode;
            }

            // locate the desired target using xpath 
            string diagXPathStr = String.Format("//*[local-name()='{0}' and namespace-uri()='{1}']", targetNode, DiagnosticsConfigXmlNamespace);
            XmlNode diagNode = mergedConfig.DocumentElement.SelectSingleNode(diagXPathStr);

            // create an import node and then append to the correct location
            XmlDocument diagnosticsConfigXml = new XmlDocument();
            diagnosticsConfigXml.LoadXml(mergeXmlStr);

            XmlNode importNode = mergedConfig.ImportNode(diagnosticsConfigXml.DocumentElement, true);
            diagNode.AppendChild(importNode);

            // Note : Currently any pre-existing user of the diagnostics configuration will be expected 
            // to follow convention of specifying storage account name in the xml configuration so that 
            // it can be persisted across configuration changes being made by multiple users. 

            // remove any stray xmlns="" attribute from xml string prior to use, and add the current storage account name
            string mergedConfiguration = mergedConfig.DocumentElement.InnerXml;
            mergedConfiguration = mergedConfiguration.Replace(string.Format(" xmlns=\"{0}\"", DiagnosticsConfigXmlNamespace), "");
            mergedConfiguration = mergedConfiguration.Replace(" xmlns=\"\"", "");

            // now add extension using the new configuration
            PublicConfiguration = GetJsonEncodedDiagnosticsConfig(mergedConfiguration);
            PrivateConfiguration = GetPrivateConfiguration();
            RemovePredicateExtensions();
            AddResourceExtension();
        }

        protected void EnableMonitoring()
        {
            // retrieve any pre-existing diagnostics extension
            var ext = GetDiagnosticsExtensionContext();

            if ((ext == null) &&
                 ((monitoringAction == MonitoringActionType.Disable) || (monitoringAction == MonitoringActionType.NoActionRequested)))
            {
                // if there was no pre-existing diagnostics extension there is 
                // nothing to do in either of these two cases so exit early 

                // note the user may not have provided a storage account either
                // so this check is performed prior to storage account validation                
                return;
            }

            // establish the storage account name to be associated with monitoring
            if (string.IsNullOrWhiteSpace(StorageAccountName))
            {
                // not specified as a parameter, try to use any value found in config
                StorageAccountName = monitoringStorageAccountName;
            }

            if (string.IsNullOrWhiteSpace(StorageAccountName))
            {
                // unable to find the storage account name as a parameter or as a config
                ThrowTerminatingError(new ErrorRecord(
                            new Exception("ServiceExtensionMissingAntimalwareMonitoringStorageAccountName"),
                            string.Empty,
                            ErrorCategory.InvalidData,
                            null));
            }
            else
            {
                ValidateStorageAccount();
            }

            if (ext != null)
            {
                // save the current configuration of the diagnostics extension
                // in the event we do not end up needing to modify it but need
                // to persist the config in the final call to update
                PublicConfiguration = ext.PublicConfiguration;
                PrivateConfiguration = GetPrivateConfiguration();
            }

            switch (monitoringAction)
            {
                case (MonitoringActionType.Enable):
                    if (ext == null)
                    {
                        AddNewAntimalwareMonitoringConfig();
                    }
                    else
                    {
                        // extension already exists, check to see if it already contains antimalware data source
                        if (!ext.AntimalwareMonitoringConfiguration.Contains(DiagnosticsConfigAntimalwareProviderToken))
                        {
                            // antimalware data source is not already in the configuration, merge it 
                            // with existing config (tracking perf counters, other event logs, etc.)
                            MergeAntimalwareMonitoringIntoExistingConfig(ext.AntimalwareMonitoringConfiguration, ext.ReferenceName);
                        }
                    }
                    break;

                case (MonitoringActionType.Disable):
                    if (ext != null)
                    {
                        RemoveExistingAntimalwareMonitoringConfig();
                    }
                    break;

                case (MonitoringActionType.NoActionRequested):
                    break;

                default:
                    break;
            }
        }

        protected void RemoveExistingAntimalwareMonitoringConfig()
        {
            // this does not remove the diagnostics extension entirely, it only removes the portion of the 
            // diagnostics configuration that monitors antimalware events- everything else will remain 
            // in order to avoid doing harm to any other users who may be sharing the diagnostics extension 

            var ext = GetDiagnosticsExtensionContext();

            if (ext!=null)
            {
                // add root element back to xml string (not preserved by diagnostics extension)
                string tmpXmlString = string.Format("<PublicConfig xmlns=\"{0}\">{1}</PublicConfig>",DiagnosticsConfigXmlNamespace, ext.AntimalwareMonitoringConfiguration);
                string AntimalwareDataSourceName = "System!*[System[Provider[@Name='Microsoft Antimalware']]]";

                XmlDocument tmpXmlDoc = new XmlDocument();
                tmpXmlDoc.LoadXml(tmpXmlString);

                // retrieve storage account name from public configuration
                string stgAcctNameXPath = string.Format(@"//*[local-name()='{0}' and namespace-uri()='{1}']", StorageAccountElementName, DiagnosticsConfigXmlNamespace);
                XmlNode stgAcctNameNode = tmpXmlDoc.DocumentElement.SelectSingleNode(stgAcctNameXPath);
                if (stgAcctNameNode != null)
                {
                    StorageAccountName = stgAcctNameNode.InnerText;
                }
                if (string.IsNullOrWhiteSpace(StorageAccountName))
                {
                    // do not modify diagnostics config without including the storage account
                    // throw terminating exception since it is not possible to preserve the 
                    // existing storage account with the configuration if it doesn't have a  
                    // hint to what the last storage account was in the public configuration 
                    ThrowTerminatingError(new ErrorRecord(
                        new Exception("ServiceExtensionExistingMonitoringConfigurationIsMissingStorageAccountNameElement"),
                        string.Empty,
                        ErrorCategory.InvalidData,
                        null));

                    return;
                }
                else
                {
                    // check the storage account and initialize for use
                    ValidateStorageAccount();
                }

                // locate the antimalware data source node in the document 
                string antimalwareDataSourceXPath = string.Format(@"//*[local-name()='{0}' and @name=""{1}"" and namespace-uri()='{2}']", "DataSource", AntimalwareDataSourceName, DiagnosticsConfigXmlNamespace);
                XmlNode antimalwareDataSourceNode = tmpXmlDoc.DocumentElement.SelectSingleNode(antimalwareDataSourceXPath);
                if (antimalwareDataSourceNode != null)
                {
                    XmlNode windowsEventLogNode = antimalwareDataSourceNode.ParentNode;
                    if (windowsEventLogNode.RemoveChild(antimalwareDataSourceNode) != null)
                    {
                        // remove the windows event log if there are no other child data sources present
                        // as will be required for schema validation to succeed when sending the new config
                        // any other data sources outside of the windows event log are left untouched 
                        if (!windowsEventLogNode.HasChildNodes)
                        {
                            windowsEventLogNode.ParentNode.RemoveChild(windowsEventLogNode);
                        }
                    }

                    // convert back to xml fragment, set configuration fields accordingly, add the extension
                    string configFrag = tmpXmlDoc.DocumentElement.InnerXml;
                    configFrag = configFrag.Replace(" xmlns=\"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration\"", "");
                    PublicConfiguration = GetJsonEncodedDiagnosticsConfig(configFrag);
                    PrivateConfiguration = GetPrivateConfiguration();
                    RemovePredicateExtensions();
                    AddResourceExtension();
                }
                else
                {
                    // no existing antimalware data source was found needing removal
                    return;
                }
            }
        }
    }
}